{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/functors-and-mondads-javascript","result":{"data":{"post":{"__typename":"MdxPost","slug":"/functors-and-mondads-javascript","title":"Functors and Monads in Javascript","date":"16.07.2018","tags":[{"name":"Functional Programming","slug":"functional-programming"},{"name":"Javascript","slug":"javascript"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Functors and Monads in Javascript\",\n  \"tags\": [\"Functional Programming\", \"Javascript\"],\n  \"date\": \"2018-07-16T00:00:00.000Z\",\n  \"slug\": \"/functors-and-mondads-javascript\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Functors and Monads are concepts of functional programming. They have heavy mathematical background which sometimes overwhelms developers. In here we\\u2019ll be ignoring the mathematics and try to understand what they are and why they are useful.\"), mdx(\"h3\", null, \"Functor\"), mdx(\"blockquote\", null, mdx(\"h1\", {\n    parentName: \"blockquote\"\n  }, \"It is an object in javascript that implements a map method, that after running over the values in the object return a new object.\")), mdx(\"p\", null, \"Well, that does good for a definition, but what does it actually mean? Functors are basically containers. i.e. they just store values like any javascript object. Take a look at the code snippet below :\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1096px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/ff993254b3d5b9fb99774e1c223a9088/8ae78/1*NDp87y1asm-RC-oj7XSbTQ.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"41.29692832764505%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABfklEQVQoz53Ou07CUBwG8L6EiaQUqNECAi0ttReghUIhROPtFVBfQjeVxMhggoOJiw7qoq/gom4GB50YjIsjkyZ2O5/nAGpkMg6//HMu33cO9342heBCpGL4OP8flmXeaBfXPxFx3ZrB5aaEq83hvNyShvPL+PrbDK62hhnW0T8VwT0fRbHq61go20g0DESzJkSZUhhjICYbg/UUk7V+mVZN8CkbtYqGF9rFPR4IaFQ1KEYFStGFki9Btl3M6kVk5kpQTA/Zgoe06SCRsyFpJmWNpkn3TERlG76n4Yl2cd19AfWqipThw3EX4DQWYdbq0Ms1WJV5qFYZululjxTpIxYSo5Ivydzw176nottmhW2BOK5OQhmHROU8EeQCCY+moOQJn7YIn7JIOG2TcIbuj4nQuxPJArELOfJAu7jeYQStNQkbqwmsL0toLjHxb2vLP5rj6Pn6SnyQ3W1KYF3c63Hso9cJB/d7oeBuZzK42Z4Mbv+I3WUZlu11+IB1fQL9bUIG6X1cSwAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"A simple functor that just stores a value.\",\n    \"title\": \"A simple functor that just stores a value.\",\n    \"src\": \"/static/ff993254b3d5b9fb99774e1c223a9088/8ae78/1*NDp87y1asm-RC-oj7XSbTQ.png\",\n    \"srcSet\": [\"/static/ff993254b3d5b9fb99774e1c223a9088/3cf3e/1*NDp87y1asm-RC-oj7XSbTQ.png 293w\", \"/static/ff993254b3d5b9fb99774e1c223a9088/78a22/1*NDp87y1asm-RC-oj7XSbTQ.png 585w\", \"/static/ff993254b3d5b9fb99774e1c223a9088/8ae78/1*NDp87y1asm-RC-oj7XSbTQ.png 1096w\"],\n    \"sizes\": \"(max-width: 1096px) 100vw, 1096px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n  \"), \"\\n    \"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A simple functor that just stores a value.\")), mdx(\"p\", null, \"Hold on, but according to the definition, functor must contain a function called \\u2018map\\u2019! So let\\u2019s define that too, But before that let\\u2019s define a method \\u2018of\\u2019 that returns a new Functor on being called with a value :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const Functor = function (val) {\\n    this.attr = val;\\n}\\n\\nFunctor.of = function (val) {\\n    return new Functor(val);\\n}\\n\\nFunctor.prototype.map = function (fn) {\\n    return Functor.of(fn(this.attr));\\n}\\n\\nlet double = (x) => x + x;\\nconsole.log(Functor.of(3).map(double)) \\n\\n/*\\nPrints the following on the console: \\nFunctor { attr: 6 } \\n*/\\n\")), mdx(\"p\", null, \"Now, take a look at the map function. It just calls the function \\u2018fn\\u2019 passed to it as a parameter and executes it with attribute \\u2018attr\\u2019 of the Functor as an argument. This newly created functor is returned. Line 13 defines a function that doubles the attribute passed to it. Line 14 logs the Functor returned after running map function with the double function.\"), mdx(\"p\", null, \"You might be wondering what on earth does \\u2018map\\u2019 or mapping mean! Map is a function that takes a functor object, basically a value/set of values and processes them via a function that is given to it as a parameter. Then collects these processed values and puts them in a new functor object and returns it.\"), mdx(\"p\", null, \"So basically functor is an object that has a method called \\u2018map\\u2019 defined in it, for example, Arrays. Pointed Functors are nothing but functors with an \\u2018of\\u2019 function defined in it that returns a new Functor, Just like the functor we defined above. The map function can also be chained :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"\\nvar res = Functor.of(\\\"Nobody\\\")\\n    .map((val) => val.toUpperCase())\\n    .map((val) => \\\"Hello \\\" + val);\\n\\nconsole.log(res); // Functor { attr: 'Hello NOBODY' }\\n\\n\")), mdx(\"p\", null, \"You can see we just chained 2 maps one after the other. The first one returns a Functor with \\u2018attr\\u2019 as uppercase the \\u2018attr\\u2019 of the first functor. The second prepends \\u201CHello\\u201D to it.\"), mdx(\"p\", null, \"The map function basically allows functions to operate on any arbitrary data structure. Do you realize how powerful it is! So now you can define a function \\u2018capitalize\\u2019 that capitalizes string which was defined for a string and takes a string as a parameter. But this function can be run over all the elements in an array/tree or any data-structure for that matter of fact, without actually caring about the implementation. i.e we can focus more on what to do rather than how its to be done.\"), mdx(\"h3\", null, \"Monads\"), mdx(\"blockquote\", null, mdx(\"h1\", {\n    parentName: \"blockquote\"\n  }, \"It is a functor in javascript that implements a flatMap method.\")), mdx(\"p\", null, \"What is a flatMap? it is a function that first maps each element using a mapping function and then flattens it by a depth of one. By flattening we mean we concatenate the sub-arrays to the original array. Look at the code snippet below.\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1170px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/452cf384c2be6cb64eb0fdc58c7eb1f5/e4ee8/1*GX3itu0ejzenIK_RxNcRlw.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"37.883959044368595%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABKElEQVQoz53MPU7CAACG4R7AKg4qxhihlLYxFOgvLYUAQooHcHECIptxUsEY4+Sm4i2McfAKXkBNHE28gTdQw2tJHIw6VIcn+fINr3A2M+ZUfGOU+O71l++n808XiTGj2XeETfWYDXtAKzukLQ8J5QHtyf6D9ewBobLPcP4Roeia6E0duVQk6xZQvCKSk2fFypGy9VjSVp4lR6a/eIOw6oToQRu/FmJ4DUx/Db3UQLMqqEY5Fs2okDEteslrhJzTIh80KUVBy6tjRnKlGqpZRjH8WFQjiIIm3YUrhKzroVV9CrUAzXNQI4rnknEtJNuIJWNbLDsaneQlQl3appzu4qU6+FKX8hdBphePtEVV7rMzd4twNP3MnvjArnj3P1MT9xyKT5wkXvgA608rHWt4XjYAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"1 GX3itu0ejzenIK RxNcRlw\",\n    \"title\": \"1 GX3itu0ejzenIK RxNcRlw\",\n    \"src\": \"/static/452cf384c2be6cb64eb0fdc58c7eb1f5/105d8/1*GX3itu0ejzenIK_RxNcRlw.png\",\n    \"srcSet\": [\"/static/452cf384c2be6cb64eb0fdc58c7eb1f5/3cf3e/1*GX3itu0ejzenIK_RxNcRlw.png 293w\", \"/static/452cf384c2be6cb64eb0fdc58c7eb1f5/78a22/1*GX3itu0ejzenIK_RxNcRlw.png 585w\", \"/static/452cf384c2be6cb64eb0fdc58c7eb1f5/105d8/1*GX3itu0ejzenIK_RxNcRlw.png 1170w\", \"/static/452cf384c2be6cb64eb0fdc58c7eb1f5/e4ee8/1*GX3itu0ejzenIK_RxNcRlw.png 1496w\"],\n    \"sizes\": \"(max-width: 1170px) 100vw, 1170px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"As you can see a flat of depth 1 unwraps an array with 1 level of nesting, while a flat of depth 2 unwraps an array with 2 levels of nesting.\\nSo now let\\u2019s look at the implementation of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"flatMap\"), \" :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"arr = [1,2,3,4,5]\\n\\nfunction map(arr,fn) {\\n    res = [];\\n    for(i in arr) {\\n        res.push(fn(arr[i]));\\n    }\\n    return res;\\n} \\n\\n// maps the function and the flattens it to a depth of one. \\nfunction flatMap(arr,fn) {\\n    return Array.prototype.concat.apply([],map(arr,fn));\\n}\\n\\nconst mapperFn = (x) => {\\n    return [2*x];\\n}\\n\\nconsole.log(map(arr,mapperFn)); // [ [ 2 ], [ 4 ], [ 6 ], [ 8 ], [ 10 ] ]\\nconsole.log(flatMap(arr,mapperFn)); // [ 2, 4, 6, 8, 10 ]\\n\")), mdx(\"p\", null, \"Let\\u2019s try to understand Line 13. So we are basically calling the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Array.prototype.concat\"), \" function with an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"apply\"), \" method over it. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"concat\"), \" function takes appends the arguments to the array on which it was called on. The apply function reassigns the this variable to its first argument and the other arguments as params to the function it was called on. For example, in this case, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"concat\"), \" function will be called with the empty array \\u201C[]\\u201D as the array on which it will be operating, and the value returned from map(arr,fn) as the argument to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"concat\"), \" function. Basically, it translated to :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"[].concat(map(arr,fn));\\n\")), mdx(\"p\", null, \"The mapper function takes a variable and returns an array with the double of the variable as the only element in it. Now the difference of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"map\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"flatMap\"), \" can be noticed here. Map returns an array with each element inside it within an array of its own, while \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"flatMap\"), \" flattens it and returns an array with individual elements.\"), mdx(\"p\", null, \"You might be thinking where monads are used. Javascript promises are monads! they implement flatMap method using the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"then\"), \" function. Think of it, Promises represent the promise object and does not represent the data that it holds. The then function takes a mapper function and maps the value in the promise and returns a flattened value rather than the promise.\"), mdx(\"p\", null, \"That\\u2019s all for Functors and Monads. I will try to explain the apply() function more detailed in an upcoming post. Happy coding till then :) !\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Functors and Monads are concepts of functional programming. They have heavy mathematical background which sometimes overwhelms developersâ€¦","timeToRead":3,"banner":null}},"pageContext":{"slug":"/functors-and-mondads-javascript","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["1581887981","3787687951","3787687951"]}