{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/javascript-exec-context","result":{"data":{"post":{"__typename":"MdxPost","slug":"/javascript-exec-context","title":"Javascript Scope and Execution Context","date":"01.07.2018","tags":[{"name":"Javascript","slug":"javascript"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Javascript Scope and Execution Context\",\n  \"tags\": [\"Javascript\"],\n  \"date\": \"2018-07-01T00:00:00.000Z\",\n  \"slug\": \"/javascript-exec-context\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Variable Scopes and the this keyword is a pretty confusing concept in Javascript. It is something a lot of Javascript developers feel uneasy about. In this post, we\\u2019ll try to understand what Variable scopes are look into what is an execution context.\"), mdx(\"h3\", null, \"Scope\"), mdx(\"p\", null, \"The first thing that we need to understand is that even though javascript is an interpreted language, the code undergoes a process called Lexing before the execution. So what is Lexing? It is a process which examines the source code and assigns semantic meaning to all tokens in the code.\"), mdx(\"p\", null, \"First, let\\u2019s define scope. Scope can be defined as the area of code in which the variable is accessible, Its simple as that. Now coming to Lexical Scope, it is scope that is defined at the lexing time. i.e when the compiler is parsing the source code and assigns meaning to variables used in the code, it simultaneously defines the scope for them.\"), mdx(\"p\", null, \"Now we need to understand how scopes work in javascript. In javascript, scopes work a bit differently unlike other languages like C++, Java etc. There are just two types of scopes :\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Global Scope:\"), \" These variables are accessible across the whole file.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Function Scope:\"), \" There variables are accessible only inside the function they are defined in.\"), mdx(\"p\", null, \"Something interesting to note is that there\\u2019s no block scope in javascript. Another interesting thing is, in case of nested functions variables inside a function can access variables defined in the outer function. This property is called Closure, to know more \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://medium.com/@kanishkarj/higher-order-functions-and-closures-6a9dccb2e052\"\n  }), \"click here\"), \".\"), mdx(\"h3\", null, \"Execution Context\"), mdx(\"p\", null, \"Scope and Execution Context when defined sound very similar, and that is a misconception that every new developer has. Execution context can be defined as the environment in which the code is executed.\"), mdx(\"p\", null, \"Every time a javascript file is processed, a default Execution Context (EC) is created the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Global Execution Context\"), \". All the code has access to this EC. Every time a function is called inside the global execution context or inside any function, a new execution context called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Functional Execution Context\"), \". The JS engine handles these EC\\u2019s with the help of a stack called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Execution Context Stack\"), \". The global EC is present by default in the stack, and every time a function is called a new EC is created with the variables defined in it and it is pushed into the stack. Once all the code in the function is executed it pops it and runs the code in the EC below it. Then comes the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"eval()\"), \" function, it allows us to execute any expression passed to it. It is not considered safe to use eval(), check out this article by Mozilla to know more.\"), mdx(\"p\", null, \"The Execution context is created in 2 stages:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Creation Stage:\"), \" when the function is called, but it has not been executed yet :\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Create the Scope Chain.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Instantiate the variables, functions, and arguments.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Determine the value of the this keyword.\"))), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Activation / Code Execution Stage:\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assign values, references to functions and interpret / execute code.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const ExecutionContext = {\\n variableObject: {}, // All the variable, arguments and inner function details of the current context\\n scopechain: [], // List of all the scopes inside which the current function is\\n this // Value of this \\n}\\n\")), mdx(\"p\", null, \"Let\\u2019s look at an example to understand how Execution Context stack works :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var a = 8;\\n\\nfunction inner() {\\n    console.log(\\\"I'm Inner.\\\");\\n}\\n\\nfunction outer() {\\n    inner();\\n    console.log(\\\"I'm Outer.\\\");\\n}\\n\\nouter();\\n\\n\")), mdx(\"p\", null, \"Now let\\u2019s see step by step how the execution context stack is operated :\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"First, the Global context is pushed into the stack.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Line no. 12 calls function outer, then the engine creates and pushes a new execution stack for the outer function.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Now inside the outer function, we are called inner function, which is not defined in the outer function. Now we pull off the definition of inner function from the global scope. And hence a new scope for the inner function is created.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The Stack currently contains inner over outer over global.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Now when we reach the end of function inner, the EC is popped out of the stack. Then when we reach the end of function outer, its EC is popped out of the stack.\"))), mdx(\"h3\", null, \"Scope Chain\"), mdx(\"p\", null, \"Scope chain is a list of all variable objects of functions inside which the current function exists. It can be said as the array of variable objects of functions of the elements in the EC stack after the EC for the current function is created. A variable object of a function is an object that contains all the variables accessible to the function.\"), mdx(\"p\", null, \"For example, in the code snippet given above the Scope chain of function inner is :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"[ \\n inner variable object,\\n outer variable object,\\n Global variable object\\n]\\n\")), mdx(\"p\", null, \"Scope chains lay the foundation for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Closures\"), \". Closure is the property which states that a function has access to all variables which are defined by its scope chain.\"), mdx(\"p\", null, \"The main difference between Scope and Execution context is, variable scope is something developers perceive to understand the region of code the variables are accessible in. While Execution context is something the javascript engine uses while parsing your code.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Variable Scopes and the this keyword is a pretty confusing concept in Javascript. It is something a lot of Javascript developers feel uneasyâ€¦","timeToRead":3,"banner":null}},"pageContext":{"slug":"/javascript-exec-context","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["1581887981","3787687951","3787687951"]}