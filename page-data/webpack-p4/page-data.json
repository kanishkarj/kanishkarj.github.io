{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/webpack-p4","result":{"data":{"post":{"__typename":"MdxPost","slug":"/webpack-p4","title":"Configuring Webpack 4 (Part 4) Production and Code splitting","date":"14.05.2018","tags":[{"name":"Webpack","slug":"webpack"},{"name":"Web Development","slug":"web-development"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this post we\\u2019ll make some changes to our configuration so that the finally built files are ready for production. If you notice, /dist/assets/js/app.bundle.js is a huge file. Now as we start using more libraries the file gets bigger and bigger. That impacts the performance of the application as the browser will have to load bigger files. One way to reduce the file size is to minimize the js files.\"), mdx(\"h2\", null, \"Minimizing JS files\"), mdx(\"p\", null, \"To minimze files we use uglifyjs-webpack-plugin. To configure it, we first import \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"webpack.common.js\"), \" in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"webpack.prod.js\"), \" :\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"webpack.prod.js\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const merge = require('webpack-merge');\\nconst common = require('./webpack.common.js');\\nconst webpack = require('webpack');\\nmodule.exports = merge(common, {\\n  \\n});\\n\")), mdx(\"p\", null, \"Now run the follwing on command line to install \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"uglifyjs-webpack-plugin\"), \" :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"npm i -D uglifyjs-webpack-plugin\\n\")), mdx(\"p\", null, \"Lets import it inside our file :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"// ...\\nconst UglifyJSPlugin = require('uglifyjs-webpack-plugin');\\n\")), mdx(\"p\", null, \"The config for minimzing the files :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"      module.exports = merge(common, {\\n      devtool: 'source-map',\\n      plugins: [\\n        new UglifyJSPlugin({\\n          sourceMap: true\\n        })\\n      ]\\n    });\\n\")), mdx(\"p\", null, \"devtool: 'source-map' : A full SourceMap is emitted as a separate file. It adds a reference comment to the bundle so development tools know where to find it.\"), mdx(\"p\", null, \"Run npm run build:prod in the command line. Now if you open \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"/dist/assets/js/app.bundle.js\"), \" you\\u2019ll notice the code has been minified, i.e the whole code is in one line.\"), mdx(\"p\", null, \"We\\u2019ll also specify that Node js is running under production mode, so that webpack can manage the libraries accordingly, i.e webpack can remove the testing libraries while bundling. So lets add another plugin to the plugins array :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"new webpack.DefinePlugin({\\n  'process.env.NODE_ENV': JSON.stringify('production')\\n})\\n\")), mdx(\"p\", null, \"So at the end of this we have :\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"webpack.prod.js\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const merge = require('webpack-merge');\\nconst UglifyJSPlugin = require('uglifyjs-webpack-plugin');\\nconst common = require('./webpack.common.js');\\nconst webpack = require('webpack');\\nmodule.exports = merge(common, {\\n    devtool: 'source-map',\\n    plugins: [\\n        new UglifyJSPlugin({\\n            sourceMap: true\\n        }),\\n        new webpack.DefinePlugin({\\n            'process.env.NODE_ENV': JSON.stringify('production')\\n        })\\n    ]\\n});\\n\")), mdx(\"h2\", null, \"Code Splitting in Webpack\"), mdx(\"p\", null, \"Code splitting in webpack is implemented using chunks. This can be used to improve performance of the application. For better understanding lets create another set of Js, Sass and HTML files.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"/src/assets/scss/page.scss\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scss\"\n  }), \"$bgcolor: gray;\\nbody {\\n    background: $bgcolor;\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"/src/assets/js/page.js\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"import '../scss/page.scss';\\nlet temp = \\\"page.js\\\";\\nconst func = (val) => console.log(val);\\nfunc(temp);\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"/src/page.html\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-html\"\n  }), \"<!DOCTYPE html>\\n<html>\\n<head>\\n    <meta charset=\\\"utf-8\\\" />\\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\\n    <title>Page Title</title>\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\">\\n</head>\\n<body>\\n    <h1>Page Chunk</h1>\\n</body>\\n</html>\\n\")), mdx(\"p\", null, \"We\\u2019ll have to make some modifications in\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" webpack.common.js \"), \"to load these new files that we created :\"), mdx(\"h2\", null, \"Add another entry point\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const config = {\\n  entry: {\\n    app: './assets/js/app.js',\\n    page: './assets/js/page.js'\\n  },\\n  // ...\\n}\\n\")), mdx(\"p\", null, \"Here app and page are chunk names. Chunks are basically names used to identify bundles. Lets test it, run npm run build. You should see 2 different files created \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"app.bundle.js\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"page.bundle.js\"), \" . But if you remember we didn\\u2019t specify any output path for the other file. That wasn\\u2019t a problem as the specifed output path was \", \"[name]\", \".bundle.js, hence a file is created for each chunk and named as specified.\"), mdx(\"h2\", null, \"Specify the Chunks in HTML Plugin\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const config = {\\n    // ...\\n    plugins: [\\n        // ...\\n        new HtmlWebpackPlugin({\\n            filename: 'index.html',\\n            template: 'index.html',\\n            chunks: ['app']\\n        }),\\n        new HtmlWebpackPlugin({\\n            filename: 'page.html',\\n            template: 'page.html',\\n            chunks: ['page']\\n        }),\\n    ]\\n}```\\n\\nWe have created a new instance of HTMLWebpackPlugin with the configuration for *page.html*. Now below it we have added a new line called chunks, which is an array that defines all the chunks the particular html file will be using. On building the project you\\u2019ll notice that 2 files are created *index.html* and *page.html*. On opening you\\u2019ll find that the specified js file is referenced in it.\\n\\nThe final complete repository can be viewed [here](https://github.com/kanishkarj/webpack-html-boilerplate).\\n\\nThats it I guess, we have covered the basics of how to use webpack. This should help you build your own config as per your requirements. If you run into any issue feel free to contact me :)\\n\\n\\nexport const _frontmatter = {\\\"title\\\":\\\"Configuring Webpack 4 (Part 4) Production and Code splitting\\\",\\\"tags\\\":[\\\"Webpack\\\",\\\"Web Development\\\"],\\\"date\\\":\\\"2018-05-14T00:00:00.000Z\\\",\\\"slug\\\":\\\"/webpack-p4\\\"}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"In this post we’ll make some changes to our configuration so that the finally built files are ready for production. If you notice, /dist…","timeToRead":1,"banner":null}},"pageContext":{"slug":"/webpack-p4","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["1581887981","3787687951","3787687951"]}